# Decorator Pattern


구성중에 객체의 행동을 확장하면 실행중에 동적으로 행동을 설정할 수 있다.




## OCP  (Open-Closed Principle)

> 클래스는 확장에 대해서는 열려있어야 하지만 코드 변경에 대해서는 닫혀있어야한다. 

 -> 즉, 기존 코드를 건드리지 않고 기능을 확장하는 원칙이라고 볼 수 있나? 

가장 현명한 방법은 우리가 디자인한 것중에서 바뀔 확률이 가장 높은 부분을 중점적으로 살펴보고 원칙을 적용하는 방법이다. 하지만 우리가 바뀔 확률이 높은걸 어떻게 판단하지? 그것에 대한 근거는 어떤 부분일까 흐음... 이게 제일 중요한 안목인거 같은데 말이여

---


### 데코레이터 패턴

> 객체에서 추가적인 요건을 *동적*으로 첨가한다. 데코레이터는 서브클래스를 만든 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.

* 데코레이터의 수퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
* 한 객체를 여러개의 데코레이터로 감쌀 수 있다.
* 데코레이터는 자신이 감싸고 있는 객체와 같은 수퍼클래스를 가지고 있어서 감싸고 있는 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관이 없다.
* 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 것 외에 원하는 추가적인 작업을 수행할 수 있다.
* 객체를 데코레이터하는 것은 런타임에 수행할 수 있다.

데코레이터 패턴을 사용하는 이유는 상위 형식을 interface or abstract class로 맞추고 구성을 사용하여 자기 자신을 리턴해주는 방식으로 instance를 관리하게 된다.



결국 wrapping을 통하여 자기 자신에 property or behavior를 추가하는 작업이라고 볼 수 있다.



#### 주의할점  

- 특정 구성요소 형식을 알아내는 경우에는 쓰면 안된다.

  ```java
  Beverage beverage = new Coffee();
  if( beverage instanceof Coffee){
      println("something special");
  }
  ```

* 출력 순서 등을 바꾸기가 어렵다 -> recursive하게 호출하게 되기 때문이 아닐까?
* 결국 Decorator의 경우 Builder나 Factory에서 활용하게 된다.
* 너무 많은 클래스들(자잘한 넘들)이 만들어지게 되서 API가 지저분하게 된다. ex) java.io

---

#### 객체지향 원칙

* 바뀌는 부분은 캡슐화한다.
* 상속보다는 구성을 사용한다
* 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다
* 서로 상호작용을 하는 객체사이에서는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.
* 클래스는 확장에 대해서는 열려 있지만 변경에 대해서는 닫혀 있어야한다. (OCP)
