## Introduction - Strategy Pattern



### 디자인 첫번째 원칙

> #### 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시켜야한다

 즉, 달라지는 부분을 찾아서 나머지코드에 영향을 주지 않도록 "캡슐화" 하는 것이 디자인 패턴의 기본이다.

어떤 객체의 달라지는 부분을 찾아서 그 부분을 분리시키기 가장 좋은 방법은 특정 클래스로 분리하는 것이다.

예를 들면 우리가 만드는 게임에서 캐릭터 중 몇몇에게 run이라는 부분을 추가해야한다면 우리는 run을 형상화하는 어떤 클래스를 만드는 것이 가장 중요한 방법이라고 할 수 있다.



### 디자인 두번째 원칙

> #### 구현이 아닌 인터페이스에 맞춰서 프로그래밍 한다.

실제 실행시에 쓰이는 객체가 코드에 의해서 고정되지 않도록, 어떤 상위 형식(Super type)에 맞춰서 프로그래밍함으로써 다형성을 활용해야하 한다는 것이다. 자세히 설명하자면 상위 형식(Super Type)에 맞춰서 변수를 선언함으로서 그 구현 자체를 숨기고 인터페이스(이곳에서는 superType)에 맞춰서 프로그래밍 하는것이 좋다는 원칙이다.

``` java
// 틀린 예제
Dog dog = new Dog();
dog.bark();

//맞는 예제
Animal animal = new Dog();
animal.makeSound();

// 객체 주입을 활용하여 Dog에 대한 import도 하지 않고 쓰는 방법도 있다.
// ex) dagger2 style

@inject
Animanl animal;
animal.makeSound();
```

![Strategy](https://raw.githubusercontent.com/kimhun456/DesignPattern/master/Introduction/IMG_4BFD725C8231-1.png)

**궁금한 한 부분.**

```kotlin
// 이런식으로 Type을 추론하는 언어에서는 어떻게 활용할 수 있을까????
val dog = getDog() // 여기서는 무조건 Dog이라는 객체로 쓰이고 animal로 쓰이지 않았을 텐데?!
dog.bark()
```



동적으로 변경할 수 있도록 setBehivor을 이용 할 수 있다.



### 알고리즘군 == Strategy Pattern

지금까지 우리가 분리했던 Behavoir를 알고리즘군 이라고 생각하면 우리가 지역에 따라 달라지는 세금 계산법 등을 구현할 때 유용하게 쓸 수 있다.



### 디자인 세번째 원칙

> ##### 상속보다는 구성을 사용하자

상속을 사용하는 것보다 구성을 사용함으로서 시스템의 유연성을 크게 향상 시킬 수 있다. 구성요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행시에 행동을 바꿀수 있게 해준다. 



### Strategy Pattern

> ##### 알고리즘에 대한 구현을 숨기고 알고리즘을 사용할 때 **구성**과 캡슐화를 사용하는 패턴

예를 들면 우리가 원하는 run이 뛰어서 도망가는 경우와 화면 밖으로 벗어나서 도망가는 경우가 있다면 동적으로 그 ***행동*** 을 바꿔칠 수 있도록해준다.



### 디자인패턴 배움의 이유

1. 디자인 패턴이란 개발자들 사이에서 모두 이해할수 있는 **용어**들을 제공하는 역할을 하게 된다.
2. 디자인 패턴은 먼저 개발자의 머리속으로 들어가고 이 저장된 디자인패턴을 통하여 코드를 짤때, 새롭게 클래스와 객체를 구성하여 어떤문제를 **해결하는 방법을 제공**하게 된다.
3. 전문 용어를 사용하여 개발 팀의 능력을 극대화 할 수 있다.



## 디자인 도구상자 

* ###### 객체지향의 기초 

  * 추상화
  * 캡슐화
  * 다형성
  * 상속

* ###### 객체지향 원칙

  * 바뀌는 부분은 캡슐화 한다.
  * 상속보다는 구성을 사용한다.
  * 구현이 아닌 인터페이스에 맞춰서 사용한다.

* ###### 객체지향 패턴

  * Strategy Pattern - 알고리즘 군을 정의하고 각각을 캡슐화하여 바꿔 쓸 수 있게 만듭니다. 스트레이티지 패턴을 이용하면 알고리즘을 활용하는 클라이언트와 독립적으로 알고리즘을 변경 할 수 있습니다.

